/* Copyright 2017 R. Thomas
 * Copyright 2017 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "LIEF/PE/Structures.hpp"
#include "LIEF/PE/EnumToString.hpp"
#include <map>

namespace LIEF {
namespace PE {

const char* to_string(PE_TYPE e) {
  const std::map<PE_TYPE, const char*> enumStrings {
    { PE_TYPE::PE32,     "PE32" },
    { PE_TYPE::PE32_PLUS,"PE32_PLUS" },
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}

const char* to_string(DATA_DIRECTORY e) {
  const std::map<DATA_DIRECTORY, const char*> enumStrings {
    { DATA_DIRECTORY::EXPORT_TABLE,            "EXPORT_TABLE" },
    { DATA_DIRECTORY::IMPORT_TABLE,            "IMPORT_TABLE" },
    { DATA_DIRECTORY::RESOURCE_TABLE,          "RESOURCE_TABLE" },
    { DATA_DIRECTORY::EXCEPTION_TABLE,         "EXCEPTION_TABLE" },
    { DATA_DIRECTORY::CERTIFICATE_TABLE,       "CERTIFICATE_TABLE" },
    { DATA_DIRECTORY::BASE_RELOCATION_TABLE,   "BASE_RELOCATION_TABLE" },
    { DATA_DIRECTORY::DEBUG,                   "DEBUG" },
    { DATA_DIRECTORY::ARCHITECTURE,            "ARCHITECTURE" },
    { DATA_DIRECTORY::GLOBAL_PTR,              "GLOBAL_PTR" },
    { DATA_DIRECTORY::TLS_TABLE,               "TLS_TABLE" },
    { DATA_DIRECTORY::LOAD_CONFIG_TABLE,       "LOAD_CONFIG_TABLE" },
    { DATA_DIRECTORY::BOUND_IMPORT,            "BOUND_IMPORT" },
    { DATA_DIRECTORY::IAT,                     "IAT" },
    { DATA_DIRECTORY::DELAY_IMPORT_DESCRIPTOR, "DELAY_IMPORT_DESCRIPTOR" },
    { DATA_DIRECTORY::CLR_RUNTIME_HEADER,      "CLR_RUNTIME_HEADER" }
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}


const char* to_string(MACHINE_TYPES e) {
  const std::map<MACHINE_TYPES, const char*> enumStrings {
    { MACHINE_TYPES::MT_Invalid,                   "INVALID" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_UNKNOWN,   "UNKNOWN" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_AM33,      "AM33" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_AMD64,     "AMD64" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_ARM,       "ARM" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_ARMNT,     "ARMNT" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_EBC,       "EBC" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_I386,      "I386" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_IA64,      "IA64" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_M32R,      "M32R" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_MIPS16,    "MIPS16" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_MIPSFPU,   "MIPSFPU" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_MIPSFPU16, "MIPSFPU16" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_POWERPC,   "POWERPC" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_POWERPCFP, "POWERPCFP" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_R4000,     "R4000" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_SH3,       "SH3" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_SH3DSP,    "SH3DSP" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_SH4,       "SH4" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_SH5,       "SH5" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_THUMB,     "THUMB" },
    { MACHINE_TYPES::IMAGE_FILE_MACHINE_WCEMIPSV2, "WCEMIPSV2" }
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}



const char* to_string(HEADER_CHARACTERISTICS e) {
  const std::map<HEADER_CHARACTERISTICS, const char*> enumStrings {
    { HEADER_CHARACTERISTICS::IMAGE_FILE_RELOCS_STRIPPED,         "RELOCS_STRIPPED" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_EXECUTABLE_IMAGE,        "EXECUTABLE_IMAGE" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_LINE_NUMS_STRIPPED,      "LINE_NUMS_STRIPPED" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_LOCAL_SYMS_STRIPPED,     "LOCAL_SYMS_STRIPPED" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_AGGRESSIVE_WS_TRIM,      "AGGRESSIVE_WS_TRIM" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_LARGE_ADDRESS_AWARE,     "LARGE_ADDRESS_AWARE" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_BYTES_REVERSED_LO,       "BYTES_REVERSED_LO" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_32BIT_MACHINE,           "32BIT_MACHINE" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_DEBUG_STRIPPED,          "DEBUG_STRIPPED" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP, "REMOVABLE_RUN_FROM_SWAP" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_NET_RUN_FROM_SWAP,       "NET_RUN_FROM_SWAP" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_SYSTEM,                  "SYSTEM" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_DLL,                     "DLL" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_UP_SYSTEM_ONLY,          "UP_SYSTEM_ONLY" },
    { HEADER_CHARACTERISTICS::IMAGE_FILE_BYTES_REVERSED_HI,       "BYTES_REVERSED_HI" }
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}


const char* to_string(SUBSYSTEM e) {
  const std::map<SUBSYSTEM, const char*> enumStrings {
    { SUBSYSTEM::IMAGE_SUBSYSTEM_UNKNOWN,                  "UNKNOWN" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_NATIVE,                   "NATIVE" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_WINDOWS_GUI,              "WINDOWS_GUI" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_WINDOWS_CUI,              "WINDOWS_CUI" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_OS2_CUI,                  "OS2_CUI" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_POSIX_CUI,                "POSIX_CUI" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_NATIVE_WINDOWS,           "NATIVE_WINDOWS" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_WINDOWS_CE_GUI,           "WINDOWS_CE_GUI" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_EFI_APPLICATION,          "EFI_APPLICATION" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER,  "EFI_BOOT_SERVICE_DRIVER" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER,       "EFI_RUNTIME_DRIVER" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_EFI_ROM,                  "EFI_ROM" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_XBOX,                     "XBOX" },
    { SUBSYSTEM::IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION, "WINDOWS_BOOT_APPLICATION" },
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}


const char* to_string(DLL_CHARACTERISTICS e) {
  const std::map<DLL_CHARACTERISTICS, const char*> enumStrings {
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA,       "HIGH_ENTROPY_VA" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE,          "DYNAMIC_BASE" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY,       "FORCE_INTEGRITY" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_NX_COMPAT,             "NX_COMPAT" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_NO_ISOLATION,          "NO_ISOLATION" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_NO_SEH,                "NO_SEH" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_NO_BIND,               "NO_BIND" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_APPCONTAINER,          "APPCONTAINER" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_WDM_DRIVER,            "WDM_DRIVER" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_GUARD_CF,              "GUARD_CF" },
    { DLL_CHARACTERISTICS::IMAGE_DLL_CHARACTERISTICS_TERMINAL_SERVER_AWARE, "TERMINAL_SERVER_AWARE" },
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}


const char* to_string(SECTION_CHARACTERISTICS e) {
  const std::map<SECTION_CHARACTERISTICS, const char*> enumStrings {
      { SECTION_CHARACTERISTICS::IMAGE_SCN_TYPE_NO_PAD,            "TYPE_NO_PAD" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_CNT_CODE,               "CNT_CODE" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_CNT_INITIALIZED_DATA,   "CNT_INITIALIZED_DATA" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_CNT_UNINITIALIZED_DATA, "CNT_UNINITIALIZED_DATA" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_LNK_OTHER,              "LNK_OTHER" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_LNK_INFO,               "LNK_INFO" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_LNK_REMOVE,             "LNK_REMOVE" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_LNK_COMDAT,             "LNK_COMDAT" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_GPREL,                  "GPREL" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_PURGEABLE,          "MEM_PURGEABLE" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_16BIT,              "MEM_16BIT" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_LOCKED,             "MEM_LOCKED" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_PRELOAD,            "MEM_PRELOAD" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_1BYTES,           "ALIGN_1BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_2BYTES,           "ALIGN_2BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_4BYTES,           "ALIGN_4BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_8BYTES,           "ALIGN_8BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_16BYTES,          "ALIGN_16BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_32BYTES,          "ALIGN_32BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_64BYTES,          "ALIGN_64BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_128BYTES,         "ALIGN_128BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_256BYTES,         "ALIGN_256BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_512BYTES,         "ALIGN_512BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_1024BYTES,        "ALIGN_1024BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_2048BYTES,        "ALIGN_2048BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_4096BYTES,        "ALIGN_4096BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_ALIGN_8192BYTES,        "ALIGN_8192BYTES" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_LNK_NRELOC_OVFL,        "LNK_NRELOC_OVFL" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_DISCARDABLE,        "MEM_DISCARDABLE" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_NOT_CACHED,         "MEM_NOT_CACHED" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_NOT_PAGED,          "MEM_NOT_PAGED" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_SHARED,             "MEM_SHARED" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_EXECUTE,            "MEM_EXECUTE" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_READ,               "MEM_READ" },
      { SECTION_CHARACTERISTICS::IMAGE_SCN_MEM_WRITE,              "MEM_WRITE" }
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}


const char* to_string(SECTION_TYPES e) {
  const std::map<SECTION_TYPES, const char*> enumStrings {
    { SECTION_TYPES::TEXT,       "TEXT"       },
    { SECTION_TYPES::TLS,        "TLS_"       },
    { SECTION_TYPES::IMPORT,     "IDATA"      },
    { SECTION_TYPES::DATA,       "DATA"       },
    { SECTION_TYPES::BSS,        "BSS"        },
    { SECTION_TYPES::RESOURCE,   "RESOURCE"   },
    { SECTION_TYPES::RELOCATION, "RELOCATION" },
    { SECTION_TYPES::EXPORT,     "EXPORT"     },
    { SECTION_TYPES::DEBUG,      "DEBUG"      },
    { SECTION_TYPES::UNKNOWN,    "UNKNOWN"    },
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}

const char* to_string(SYMBOL_BASE_TYPES e) {
  const std::map<SYMBOL_BASE_TYPES, const char*> enumStrings {
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_NULL,   "NULL"   },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_VOID,   "VOID"   },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_CHAR,   "CHAR"   },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_SHORT,  "SHORT"  },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_INT,    "INT"    },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_LONG,   "LONG"   },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_FLOAT,  "FLOAT"  },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_DOUBLE, "DOUBLE" },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_STRUCT, "STRUCT" },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_UNION,  "UNION"  },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_ENUM,   "ENUM"   },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_MOE,    "MOE"    },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_BYTE,   "BYTE"   },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_WORD,   "WORD"   },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_UINT,   "UINT"   },
    { SYMBOL_BASE_TYPES::IMAGE_SYM_TYPE_DWORD,  "DWORD"  },
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}

const char* to_string(SYMBOL_COMPLEX_TYPES e) {
  const std::map<SYMBOL_COMPLEX_TYPES, const char*> enumStrings {
    { SYMBOL_COMPLEX_TYPES::IMAGE_SYM_DTYPE_NULL,     "NULL"               },
    { SYMBOL_COMPLEX_TYPES::IMAGE_SYM_DTYPE_POINTER,  "POINTER"            },
    { SYMBOL_COMPLEX_TYPES::IMAGE_SYM_DTYPE_FUNCTION, "FUNCTION"           },
    { SYMBOL_COMPLEX_TYPES::IMAGE_SYM_DTYPE_ARRAY,    "ARRAY"              },
    { SYMBOL_COMPLEX_TYPES::SCT_COMPLEX_TYPE_SHIFT,   "COMPLEX_TYPE_SHIFT" },
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}


const char* to_string(SYMBOL_SECTION_NUMBER e) {
  const std::map<SYMBOL_SECTION_NUMBER, const char*> enumStrings {
    { SYMBOL_SECTION_NUMBER::IMAGE_SYM_DEBUG,     "DEBUG"     },
    { SYMBOL_SECTION_NUMBER::IMAGE_SYM_ABSOLUTE,  "ABSOLUTE"  },
    { SYMBOL_SECTION_NUMBER::IMAGE_SYM_UNDEFINED, "UNDEFINED" },
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}


const char* to_string(SYMBOL_STORAGE_CLASS e) {
  const std::map<SYMBOL_STORAGE_CLASS, const char*> enumStrings {
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_END_OF_FUNCTION,  "END_OF_FUNCTION"  },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_NULL,             "NULL"             },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_AUTOMATIC,        "AUTOMATIC"        },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_EXTERNAL,         "EXTERNAL"         },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_STATIC,           "STATIC"           },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_REGISTER,         "REGISTER"         },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_EXTERNAL_DEF,     "EXTERNAL_DEF"     },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_LABEL,            "LABEL"            },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_UNDEFINED_LABEL,  "UNDEFINED_LABEL"  },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_MEMBER_OF_STRUCT, "MEMBER_OF_STRUCT" },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_UNION_TAG,        "UNION_TAG"        },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_TYPE_DEFINITION,  "TYPE_DEFINITION"  },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_UNDEFINED_STATIC, "UDEFINED_STATIC"  },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_ENUM_TAG,         "ENUM_TAG"         },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_MEMBER_OF_ENUM,   "MEMBER_OF_ENUM"   },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_REGISTER_PARAM,   "REGISTER_PARAM"   },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_BIT_FIELD,        "BIT_FIELD"        },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_BLOCK,            "BLOCK"            },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_FUNCTION,         "FUNCTION"         },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_END_OF_STRUCT,    "END_OF_STRUCT"    },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_FILE,             "FILE"             },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_SECTION,          "SECTION"          },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_WEAK_EXTERNAL,    "WEAK_EXTERNAL"    },
    { SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_CLR_TOKEN,        "CLR_TOKEN"        },
  };
  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}


const char* to_string(RELOCATIONS_I386 e) {
  const std::map<RELOCATIONS_I386, const char*> enumStrings {
    { RELOCATIONS_I386::IMAGE_REL_I386_ABSOLUTE,  "ABSOLUTE" },
    { RELOCATIONS_I386::IMAGE_REL_I386_DIR16,     "DIR16"    },
    { RELOCATIONS_I386::IMAGE_REL_I386_REL16,     "REL16"    },
    { RELOCATIONS_I386::IMAGE_REL_I386_DIR32,     "DIR32"    },
    { RELOCATIONS_I386::IMAGE_REL_I386_DIR32NB,   "DIR32NB"  },
    { RELOCATIONS_I386::IMAGE_REL_I386_SEG12,     "SEG12"    },
    { RELOCATIONS_I386::IMAGE_REL_I386_SECTION,   "SECTION"  },
    { RELOCATIONS_I386::IMAGE_REL_I386_SECREL,    "SECREL"   },
    { RELOCATIONS_I386::IMAGE_REL_I386_TOKEN,     "TOKEN"    },
    { RELOCATIONS_I386::IMAGE_REL_I386_SECREL7,   "SECREL7"  },
    { RELOCATIONS_I386::IMAGE_REL_I386_REL32,     "REL32"    },
  };

  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}



const char* to_string(RELOCATIONS_AMD64 e) {
  const std::map<RELOCATIONS_AMD64, const char*> enumStrings {
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_ABSOLUTE, "ABSOLUTE" },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_ADDR64,   "ADDR64"   },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_ADDR32,   "ADDR32"   },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_ADDR32NB, "ADDR32NB" },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_REL32,    "REL32"    },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_REL32_1,  "REL32_1"  },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_REL32_2,  "REL32_2"  },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_REL32_3,  "REL32_3"  },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_REL32_4,  "REL32_4"  },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_REL32_5,  "REL32_5"  },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_SECTION,  "SECTION"  },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_SECREL,   "SECREL"   },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_SECREL7,  "SECREL7"  },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_TOKEN,    "TOKEN"    },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_SREL32,   "SREL32"   },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_PAIR,     "PAIR"     },
    { RELOCATIONS_AMD64::IMAGE_REL_AMD64_SSPAN32,  "SSPAN32"  },
  };

  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}



const char* to_string(RELOCATIONS_ARM e) {
  const std::map<RELOCATIONS_ARM, const char*> enumStrings {
    { RELOCATIONS_ARM::IMAGE_REL_ARM_ABSOLUTE,  "ABSOLUTE"  },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_ADDR32,    "ADDR32"    },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_ADDR32NB,  "ADDR32NB"  },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_BRANCH24,  "BRANCH24"  },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_BRANCH11,  "BRANCH11"  },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_TOKEN,     "TOKEN"     },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_BLX24,     "BLX24"     },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_BLX11,     "BLX11"     },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_SECTION,   "SECTION"   },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_SECREL,    "SECREL"    },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_MOV32A,    "MOV32A"    },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_MOV32T,    "MOV32T"    },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_BRANCH20T, "BRANCH20T" },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_BRANCH24T, "BRANCH24T" },
    { RELOCATIONS_ARM::IMAGE_REL_ARM_BLX23T,    "BLX23T"    },
  };

  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}


const char* to_string(RELOCATIONS_BASE_TYPES e) {
  const std::map<RELOCATIONS_BASE_TYPES, const char*> enumStrings {
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_ABSOLUTE,       "ABSOLUTE"  },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_HIGH,           "HIGH"      },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_LOW,            "LOW"       },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_HIGHLOW,        "HIGHLOW"   },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_HIGHADJ,        "HIGHADJ"   },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_MIPS_JMPADDR,   "JMPADDR"   },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_SECTION,        "SECTION"   },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_REL,            "REL"       },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_MIPS_JMPADDR16, "JMPADDR16" },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_IA64_IMM64,     "IMM64"     },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_DIR64,          "DIR64"     },
    { RELOCATIONS_BASE_TYPES::IMAGE_REL_BASED_HIGH3ADJ,       "HIGH3ADJ"  }
  };

  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}



const char* to_string(DEBUG_TYPES e) {
  const std::map<DEBUG_TYPES, const char*> enumStrings {
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_UNKNOWN,       "UNKNOWN"   },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_COFF,          "COFF"      },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_CODEVIEW,      "CODEVIEW"  },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_FPO,           "FPO"       },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_MISC,          "MISC"      },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_EXCEPTION,     "EXCEPTION" },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_FIXUP,         "FIXUP"     },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_OMAP_TO_SRC,   "SRC"       },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_OMAP_FROM_SRC, "SRC"       },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_BORLAND,       "BORLAND"   },
    { DEBUG_TYPES::IMAGE_DEBUG_TYPE_CLSID,         "CLSID"     },
  };

  auto   it  = enumStrings.find(e);
  return it == enumStrings.end() ? "Out of range" : it->second;
}
















} // namespace PE
} // namespace LIEF
